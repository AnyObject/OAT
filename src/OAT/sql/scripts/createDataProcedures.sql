/*    Open Auto Trading : A fully automatic equities trading platform with machine learning capabilities    Copyright (C) 2015 AnyObject Ltd.    This program is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with this program.  If not, see <http://www.gnu.org/licenses/>. */DELIMITER //DROP FUNCTION IF EXISTS `toTimeLong`//CREATE FUNCTION `toTimeLong`(dt DATETIME)  RETURNS BIGINT  DETERMINISTIC  RETURN UNIX_TIMESTAMP(dt) * 1000//DROP FUNCTION IF EXISTS `toTimeStamp`//CREATE FUNCTION `toTimeStamp`(timeLong BIGINT)  RETURNS DATETIME  DETERMINISTIC  RETURN FROM_UNIXTIME(FLOOR(timeLong / 1000))//DROP PROCEDURE IF EXISTS `getConId`//CREATE PROCEDURE `getConId` (symbol VARCHAR(50), lastDayBeforeExpiry INT)  SELECT m_conId FROM `contracts`  WHERE m_symbol = symbol  AND m_expiry >= DATE_FORMAT(ADDDATE(CURDATE(),INTERVAL lastDayBeforeExpiry DAY), '%Y%m%d')  ORDER BY m_expiry  LIMIT 1//DROP PROCEDURE IF EXISTS `getLocalSymbol`//CREATE PROCEDURE `getLocalSymbol` (symbol VARCHAR(50), exchange VARCHAR(50), lastDayBeforeExpiry INT)  SELECT `m_localSymbol` FROM `contracts`  WHERE `m_symbol` = symbol  AND     (SELECT DATE(`open`) FROM `trading_hours`    WHERE `m_exchange` = exchange    AND `close` >= NOW()    ORDER BY `open`    LIMIT 1) <= SUBDATE(DATE(`m_expiry`), INTERVAL lastDayBeforeExpiry DAY)  ORDER BY `m_expiry`  LIMIT 1//DROP PROCEDURE IF EXISTS `getTimeZone`//CREATE PROCEDURE `getTimeZone` (symbol VARCHAR(50))  SELECT m_exchange, timeZone, gmt_offset FROM `trading_hours`  WHERE m_exchange =   (    SELECT m_exchange FROM `contracts`    WHERE m_symbol = symbol    ORDER BY m_expiry DESC    LIMIT 1  )    ORDER BY open_long DESC//DROP PROCEDURE IF EXISTS `getTradingHours`//CREATE PROCEDURE `getTradingHours` (symbol VARCHAR(50), since BIGINT)  SELECT * FROM `trading_hours`  WHERE m_exchange =   (    SELECT m_exchange FROM `contracts`    WHERE m_symbol = symbol    AND open_long >= since    ORDER BY m_expiry DESC    LIMIT 1  )  AND close_long >= NOW() - INTERVAL 1 DAY  ORDER BY open_long//DROP PROCEDURE IF EXISTS `getBackDays`//CREATE PROCEDURE `getBackDays` (symbol VARCHAR(50), expiryMonths INT, lastDay INT, backDate BIGINT)BEGINSET @ex = (SELECT m_exchange FROM `contracts` WHERE m_symbol = symbol AND MOD(SUBSTRING(m_expiry, 5, 2), expiryMonths) = 0 ORDER BY m_expiry DESC LIMIT 1);SELECT * FROM  (SELECT * FROM    (SELECT       m_exchange, DATE(open_local) AS local_date, timeZone, gmt_offset,       MIN(open_long) AS day_open, MAX(close_long) AS day_close,      MIN(open_local) AS day_open_local, MAX(close_local) AS day_close_local    FROM trading_hours    WHERE m_exchange = @ex    GROUP BY local_date) AS t_day  LEFT JOIN    (SELECT       m_exchange, local_date,       t1.close_long AS break_start, t2.open_long AS break_end,      t1.close_local AS break_start_local, t2.open_local AS break_end_local    FROM      (SELECT *, DATE(open_local) AS local_date FROM trading_hours WHERE m_exchange = @ex) AS t1    JOIN      (SELECT *, DATE(open_local) AS local_date FROM trading_hours WHERE m_exchange = @ex) AS t2     USING (m_exchange, local_date)    WHERE t2.open_long > t1.open_long      AND t2.open_long > t1.close_long) AS t_break  USING (m_exchange, local_date)  ORDER BY m_exchange, local_date) AS thRIGHT JOIN  (SELECT m_conId, m_exchange, m_localSymbol, m_expiry    FROM `contracts`    WHERE m_symbol = symbol      AND MOD(SUBSTRING(m_expiry, 5, 2), expiryMonths) = 0    ORDER BY m_expiry  ) AS `t1`USING (m_exchange)WHERE day_close >= toTimeLong(NOW()) - backDate  AND day_close <= toTimeLong(NOW())  AND DAYOFWEEK(day_open_local) > 1  AND DAYOFWEEK(day_open_local) < 7  AND HOUR(day_open_local) > 6  AND DATE_FORMAT(ADDDATE(day_open_local, INTERVAL lastDay DAY),'%Y%m%d') <= m_expiry GROUP BY day_openORDER BY day_open DESC;END//DROP PROCEDURE IF EXISTS `getTicksData`//CREATE PROCEDURE `getTicksData` (conId INT, sinceDate BIGINT, endDate BIGINT)   SELECT * FROM `ticks`  WHERE m_conId = conId  AND tick_time_long >= sinceDate  AND tick_time_long <= endDate  ORDER BY tick_time_long//DROP PROCEDURE IF EXISTS `insertTick`//CREATE PROCEDURE `insertTick` (conId INT, time BIGINT, price DOUBLE, size BIGINT, newBar TINYINT(1))  REPLACE INTO `ticks`   (m_conId, tick_time_long, tick_price, tick_size, tick_newBar)   VALUES(conId, time, price, size, newBar);//DROP PROCEDURE IF EXISTS `getLastTraded`//CREATE PROCEDURE `getLastTraded`(symbol VARCHAR(20))  SELECT * FROM  (SELECT `m_symbol`, `m_exchange`, `m_currency`, `m_multiplier`, `m_priceMagnifier`, `m_commission` / `filled` AS `commission`    FROM `cash`.`orders` JOIN `contracts` USING (`m_conId`) JOIN `contract_details` USING (`m_conId`)    WHERE `m_symbol` = symbol    AND `m_status` = 'Filled'    ORDER BY `submitted_time_long` DESC    LIMIT 20  ) AS lastTraded  ORDER BY commission DESC  LIMIT 1//DELIMITER ;