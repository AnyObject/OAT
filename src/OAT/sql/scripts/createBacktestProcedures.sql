/*    Open Auto Trading : A fully automatic equities trading platform with machine learning capabilities    Copyright (C) 2015 AnyObject Ltd.    This program is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with this program.  If not, see <http://www.gnu.org/licenses/>. */DELIMITER //DROP FUNCTION IF EXISTS `toTimeLong`//CREATE FUNCTION `toTimeLong`(dt DATETIME)  RETURNS BIGINT  DETERMINISTIC  RETURN UNIX_TIMESTAMP(dt) * 1000//DROP FUNCTION IF EXISTS `toTimeStamp`//CREATE FUNCTION `toTimeStamp`(timeLong BIGINT)  RETURNS DATETIME  DETERMINISTIC  RETURN FROM_UNIXTIME(FLOOR(timeLong / 1000))//DROP PROCEDURE IF EXISTS `getBacktestSummary`//CREATE PROCEDURE `getBacktestSummary` (backtestId INT)  SELECT     id,    currency,    day_gross* multiplier - trade_count * commission * 2 AS net,    day_gross AS gross,    IF(day_gross > 0, 1 - trade_count * commission * 2 / multiplier / day_gross, NULL) AS margin,    day_count,    day_max,    day_min,    day_ratio,    day_avg,    day_stdev,    day_avg / day_stdev AS day_sharpe,    trade_count,    trade_max,    trade_min,    trade_win / trade_count AS trade_ratio,    trade_avg,    trade_stdev,    trade_avg / trade_stdev AS trade_sharpe  FROM (  SELECT * FROM     (SELECT       strategy_id AS id,       currency,      multiplier,      commission,      SUM(day_gross) AS day_gross,      COUNT(day_gross) AS day_count,      MAX(day_gross) AS day_max,      MIN(day_gross) AS day_min,      COUNT(IF(day_gross > 0, 1, NULL)) / COUNT(IF(trade_count > 0, 1, NULL)) AS day_ratio,      AVG(day_gross) AS day_avg,      STDDEV(day_gross) AS day_stdev          FROM       (SELECT strategy_id, day_id, IF(day_gross IS NULL, 0 , day_gross) AS day_gross, trade_count FROM        (SELECT strategy_id, day_id,          SUM((exit_price - enter_price) * enter_side) AS day_gross,          COUNT(enter_price) AS trade_count          FROM `backtest`.`backtest_trades`          WHERE backtest_id = backtestId          GROUP BY strategy_id, day_id        ) AS days      RIGHT JOIN         (SELECT * FROM             (SELECT strategy_id FROM `backtest`.`backtest_strategies` WHERE backtest_id = backtestId) AS s_id             CROSS JOIN            (SELECT day_id FROM `backtest`.`backtest_days` WHERE backtest_id = backtestId) AS d_id                      GROUP BY strategy_id, day_id        ) AS ids      USING (strategy_id, day_id)) AS days_with_null      JOIN (SELECT * FROM backtest_strategies WHERE backtest_id = backtestId) AS strategies USING (strategy_id)    GROUP BY strategy_id    ) AS day_summary  LEFT JOIN    (SELECT       strategy_id AS id,            COUNT(gross) AS trade_count,      MAX(gross) AS trade_max,      MIN(gross) AS trade_min,      COUNT(IF(gross > 0, 1, NULL))  AS trade_win,      AVG(gross) AS trade_avg,      STDDEV(gross) AS trade_stdev            FROM (SELECT strategy_id, (exit_price - enter_price) * enter_side AS gross FROM `backtest`.`backtest_trades` WHERE backtest_id = backtestId) AS trade_profit      GROUP BY strategy_id    ) AS trade_summary  USING (id)) AS summary//DROP PROCEDURE IF EXISTS `getBacktestBreakdown`//CREATE PROCEDURE `getBacktestBreakdown` (backtestId INT, strategyId INT)  SELECT     day,     open,     close,     volume,     ticks,    sum,    count,    max,    min,    win/ count AS win_ratio,    avg,    stdev,    avg / stdev AS sharpe  FROM (  SELECT     day_id AS day,     toTimeStamp(open) AS open,     toTimeStamp(close) As close,     volume,     tick_count AS ticks,    sum(gross) AS sum,    count(gross) AS count,    max(gross) AS max,    min(gross) AS min,    COUNT(IF(gross > 0, 1, NULL)) AS win,    AVG(gross) AS avg,    STDDEV(gross) AS stdev  FROM     `backtest`.`backtest_days`      LEFT JOIN    (SELECT         day_id,         (exit_price - enter_price) * enter_side AS gross      FROM `backtest`.`backtest_trades`       WHERE strategy_id = strategyId      AND backtest_id = backtestId    ) AS trade_profit    USING (day_id)  WHERE backtest_id = backtestId  GROUP BY day_id  ORDER BY day_id) AS breakdown//DROP PROCEDURE IF EXISTS `getStrategyVariables`//CREATE PROCEDURE `getStrategyVariables` (backtestId INT, strategyId INT)  SELECT * FROM `backtest`.`backtest_strategies`  WHERE strategy_id = strategyId  AND backtest_id = backtestId//DROP PROCEDURE IF EXISTS `clearBacktestDaysTable`//CREATE PROCEDURE `clearBacktestDaysTable` ()BEGIN  TRUNCATE  TABLE `backtest`.`backtest_days`;  END //DROP PROCEDURE IF EXISTS `insertTrade`//CREATE PROCEDURE `insertTrade` (backtest_id INT, strategy_id INT, day_id INT, trade_id INT, enter_side TINYINT(1),   enter_time_long BIGINT, enter_price DOUBLE, exit_time_long BIGINT, exit_price DOUBLE)  INSERT IGNORE INTO `backtest_trades`   (`backtest_id`, `strategy_id`, `day_id`, `trade_id`, `enter_side`, `enter_time`, `enter_price`, `exit_time`, `exit_price`)  VALUES(backtest_id, strategy_id, day_id, trade_id, enter_side, enter_time_long, enter_price, exit_time_long, exit_price);//DROP PROCEDURE IF EXISTS `getDayProfits`//CREATE PROCEDURE `getDayProfits` (backtestId INT, strategyId INT)  SELECT day_id, SUM((exit_price - enter_price) * enter_side) AS profit   FROM `backtest_trades`  WHERE strategy_id = strategyId    AND backtest_id = backtestId  GROUP BY day_id  ORDER BY day_id;//DROP PROCEDURE IF EXISTS `getTradeProfits`//CREATE PROCEDURE `getTradeProfits` (backtestId INT, strategyId INT)  SELECT day_id, trade_id, (exit_price - enter_price) * enter_side AS profit   FROM `backtest_trades`  WHERE strategy_id = strategyId  AND backtest_id = backtestId  ORDER BY day_id, trade_id;//DROP PROCEDURE IF EXISTS `insertBacktestDay`//CREATE PROCEDURE `insertBacktestDay` (backtest_id INT, day_id INT, open DOUBLE, close DOUBLE, volume BIGINT, tick_count BIGINT)  REPLACE INTO `backtest`.`backtest_days`    (`backtest_id`, `day_id`, `open`, `close`, `volume`, `tick_count`)    VALUES(backtest_id, day_id, open, close, volume, tick_count);//DROP PROCEDURE IF EXISTS `insertBacktestStrategy`//CREATE PROCEDURE `insertBacktestStrategy` (backtest_id INT, strategy_id INT, variables VARCHAR(10240), symbol VARCHAR(20), exchange VARCHAR(20), currency VARCHAR(5), multiplier DOUBLE, commission DOUBLE)  REPLACE INTO `backtest`.`backtest_strategies`    (`backtest_id`, `strategy_id`, `variables`, `symbol`, `exchange`, `currency`, `multiplier`, `commission`)    VALUES(backtest_id, strategy_id, variables, symbol, exchange, currency, multiplier, commission);//DROP PROCEDURE IF EXISTS `getDayNet`//CREATE PROCEDURE `getDayNet` (backtestId INT, strategyId INT)  SELECT toTimeLong(DATE(toTimeStamp(exit_time))) AS date, SUM((exit_price - enter_price) * enter_side) * multiplier - COUNT(trade_id) * commission * 2 AS profit  FROM `backtest_trades` JOIN `backtest_strategies` USING (backtest_id, strategy_id)  WHERE strategy_id = strategyId  AND backtest_id = backtestId  GROUP BY date  ORDER BY date;//DROP PROCEDURE IF EXISTS `getPortfolioDayNet`//CREATE PROCEDURE `getPortfolioDayNet` (strategyId INT, baseCurrency VARCHAR(5))  SELECT     toTimeLong(DATE(toTimeStamp(exit_time))) AS date,     SUM(((exit_price - enter_price) * enter_side * multiplier - commission * 2) / IF(currency = baseCurrency, 1.0, (SELECT rate FROM `data`.`rates` WHERE base = baseCurrency AND forex = currency AND rate_time <= exit_time  ORDER BY rate_time DESC LIMIT 1))) AS profit  FROM `backtest_trades` JOIN `backtest_strategies` USING (backtest_id, strategy_id)  WHERE strategy_id = strategyId  GROUP BY date  ORDER BY date;//DELIMITER ;